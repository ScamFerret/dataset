[
    {
        "thought": "I should first check the status of the URL to ensure it's accessible and to see if there are any immediate red flags.",
        "action": "AccessURL",
        "action_input": "https://www.uproperties.com/",
        "observation": "Navigating to https://www.uproperties.com/ returned status code 200"
    },
    {
        "thought": "The website is accessible. Now I should look for content on the site that may indicate it's a scam, such as unusually low prices, unrealistic money claims, psychological triggers, or outdated information.",
        "action": "ExtractText",
        "action_input": "https://www.uproperties.com/",
        "observation": "Commercial Real Estate Developers & Investors | United Properties  Skip to content Contact Search About Us Diversity, Equity & Inclusion Our Team Projects Multi-Family Industrial Senior Living Retail Office Mixed-Use Full Gallery Markets Minnesota Colorado Texas ESG Overview Environmental Sustainability Social Responsibility Governance & Responsible Investment Case Studies Careers Recent News To search this site, enter a search term Submit Cancel Play Premier Commercial Real Estate Investors & Developers Discover forward-thinking, future-changing commercial real estate development and investment in Minnesota, Texas and Colorado with more than 100 years of experience. Our Markets Austin, Texas Denver, Colorado Minneapolis, Minnesota Explore what’s going on at United Properties and learn from our team about the latest commercial real estate projects we have developed or invested in. United Properties announces its fourth Amira senior living community MINNEAPOLIS (March 20, 2024) — United Properties announced today plans to build Amira Lake Elmo, its newest 55-plus active adult rental community, located at 8695 Eagle Point Blvd., Lake Elmo, Minnesota. Link United Properties sells fully leased Trade@2534 industrial development DENVER (Feb. 12, 2024) — United Properties announced today the sale of Trade@2534, a Class A industrial development located at 4201 Ronald Reagan Blvd. in Johnstown, Colorado, to California-based Nearon Enterprises, LLC. United Properties adds Champlin property to senior living portfolio MINNEAPOLIS (Feb. 1, 2024) — United Properties announced today its acquisition of Champlin Shores, a senior living community located at 119 E. Hayden Lake Rd. in Champlin, Minnesota. Environmental, Social & Governance Terms & Conditions ©"
    },
    {
        "thought": "The extracted text does not indicate any of the typical characteristics of a scam website. Instead, it presents information related to a commercial real estate development and investment company with specific references to projects, awards, and locations in the United States. The content seems professional and related to the company's business activities. There are no unusually low prices, unrealistic money claims, psychological triggers, or signs of outdated information. To further verify the legitimacy of the website, I should check for additional details such as company existence, domain information, and online presence.",
        "action": "RetrieveWHOIS",
        "action_input": "uproperties.com",
        "observation": "{'domain': 'uproperties.com', 'servername': 'whois.networksolutions.com', 'tld': 'com', 'registered': True, 'reserved': False, 'client_hold': False, 'detail': {'registrant': ['Registrant Name: PERFECT PRIVACY, LLC', 'Registrant Organization:', 'Registrant Street: 5335 Gate Parkway care of Network Solutions PO Box 459', 'Registrant City: Jacksonville', 'Registrant State/Province: FL', 'Registrant Postal Code: 32256', 'Registrant Country: US', 'Registrant Phone: +1.5707088622', 'Registrant Phone Ext:', 'Registrant Fax:', 'Registrant Fax Ext:', 'Registrant Email: ev3cw7ka9n8@networksolutionsprivateregistration.com'], 'admin': ['Admin Name: PERFECT PRIVACY, LLC', 'Admin Organization:', 'Admin Street: 5335 Gate Parkway care of Network Solutions PO Box 459', 'Admin City: Jacksonville', 'Admin State/Province: FL', 'Admin Postal Code: 32256', 'Admin Country: US', 'Admin Phone: +1.5707088622', 'Admin Phone Ext:', 'Admin Fax:', 'Admin Fax Ext:', 'Admin Email: ev3cw7ka9n8@networksolutionsprivateregistration.com'], 'tech': ['Tech Name: PERFECT PRIVACY, LLC', 'Tech Organization:', 'Tech Street: 5335 Gate Parkway care of Network Solutions PO Box 459', 'Tech City: Jacksonville', 'Tech State/Province: FL', 'Tech Postal Code: 32256', 'Tech Country: US', 'Tech Phone: +1.5707088622', 'Tech Phone Ext:', 'Tech Fax:', 'Tech Fax Ext:', 'Tech Email: ev3cw7ka9n8@networksolutionsprivateregistration.com'], 'billing': [], 'status': ['Domain Status: clientTransferProhibited https://icann.org/epp#clientTransferProhibited'], 'date': ['Updated Date: 2024-04-24T07:25:26Z', 'Creation Date: 1996-04-04T05:00:00Z', 'Registrar Registration Expiration Date: 2028-04-05T04:00:00Z'], 'name_server': ['Name Server: NS85.WORLDNIC.COM', 'Name Server: NS86.WORLDNIC.COM']}, 'raw': ['Domain Name: UPROPERTIES.COM', 'Registry Domain ID: 133779_DOMAIN_COM-VRSN', 'Registrar WHOIS Server: whois.networksolutions.com', 'Registrar URL: http://networksolutions.com', 'Updated Date: 2024-04-24T07:25:26Z', 'Creation Date: 1996-04-04T05:00:00Z', 'Registrar Registration Expiration Date: 2028-04-05T04:00:00Z', 'Registrar: Network Solutions, LLC', 'Registrar IANA ID: 2', 'Reseller:', 'Domain Status: clientTransferProhibited https://icann.org/epp#clientTransferProhibited', 'Registry Registrant ID:', 'Registrant Name: PERFECT PRIVACY, LLC', 'Registrant Organization:', 'Registrant Street: 5335 Gate Parkway care of Network Solutions PO Box 459', 'Registrant City: Jacksonville', 'Registrant State/Province: FL', 'Registrant Postal Code: 32256', 'Registrant Country: US', 'Registrant Phone: +1.5707088622', 'Registrant Phone Ext:', 'Registrant Fax:', 'Registrant Fax Ext:', 'Registrant Email: ev3cw7ka9n8@networksolutionsprivateregistration.com', 'Registry Admin ID:', 'Admin Name: PERFECT PRIVACY, LLC', 'Admin Organization:', 'Admin Street: 5335 Gate Parkway care of Network Solutions PO Box 459', 'Admin City: Jacksonville', 'Admin State/Province: FL', 'Admin Postal Code: 32256', 'Admin Country: US', 'Admin Phone: +1.5707088622', 'Admin Phone Ext:', 'Admin Fax:', 'Admin Fax Ext:', 'Admin Email: ev3cw7ka9n8@networksolutionsprivateregistration.com', 'Registry Tech ID:', 'Tech Name: PERFECT PRIVACY, LLC', 'Tech Organization:', 'Tech Street: 5335 Gate Parkway care of Network Solutions PO Box 459', 'Tech City: Jacksonville', 'Tech State/Province: FL', 'Tech Postal Code: 32256', 'Tech Country: US', 'Tech Phone: +1.5707088622', 'Tech Phone Ext:', 'Tech Fax:', 'Tech Fax Ext:', 'Tech Email: ev3cw7ka9n8@networksolutionsprivateregistration.com', 'Name Server: NS85.WORLDNIC.COM', 'Name Server: NS86.WORLDNIC.COM', 'DNSSEC: unsigned', 'Registrar Abuse Contact Email: domain.operations@web.com', 'Registrar Abuse Contact Phone: +1.8777228662', 'URL of the ICANN WHOIS Data Problem Reporting System: http://wdprs.internic.net/', '>>> Last update of WHOIS database: 2024-04-30T08:21:50Z <<<', '', 'For more information on Whois status codes, please visit https://www.icann.org/resources/pages/epp-status-codes-2014-06-16-en', '', '', 'This listing is a Network Solutions Private Registration. Mail', 'correspondence to this address must be sent via USPS Express Mail(TM) or', 'USPS Certified Mail(R); all other mail will not be processed. Be sure to', \"include the registrant's domain name in the address.\", '', \"The data in Networksolutions.com's WHOIS database is provided to you by\", 'Networksolutions.com for information purposes only, that is, to assist you in', 'obtaining information about or related to a domain name registration', 'record. Networksolutions.com makes this information available \"as is,\" and', 'does not guarantee its accuracy. By submitting a WHOIS query, you', 'agree that you will use this data only for lawful purposes and that,', 'under no circumstances will you use this data to: (1) allow, enable,', 'or otherwise support the transmission of mass unsolicited, commercial', 'advertising or solicitations via direct mail, electronic mail, or by', 'telephone; or (2) enable high volume, automated, electronic processes', 'that apply to Networksolutions.com  (or its systems). The compilation,', 'repackaging, dissemination or other use of this data is expressly', 'prohibited without the prior written consent of Networksolutions.com.', 'Networksolutions.com reserves the right to modify these terms at any time.', 'By submitting this query, you agree to abide by these terms.', '', 'For more information on Whois status codes, please visit', 'https://www.icann.org/resources/pages/epp-status-codes-2014-06-16-en.']}"
    },
    {
        "thought": "The WHOIS information reveals that the domain uproperties.com is registered and the registration details are protected by a privacy service, which is not uncommon for legitimate businesses. The domain has been registered since 1996, which suggests a long-standing presence on the web. The status of the domain is \"clientTransferProhibited,\" which is an additional security measure to prevent unauthorized domain transfers. Now I will check the domain's certificate information to ensure there are no security issues that might be associated with scam websites.",
        "action": "RetrieveCertificate",
        "action_input": "uproperties.com",
        "observation": "[{'issuer_ca_id': 183283, 'issuer_name': \"C=US, O=Let's Encrypt, CN=E1\", 'common_name': 'uproperties.com', 'name_value': 'uproperties.com', 'id': 12520062904, 'entry_timestamp': '2024-03-28T07:56:04.414', 'not_before': '2024-03-28T06:56:04', 'not_after': '2024-06-26T06:56:03', 'serial_number': '035c71a696301d4580f8a7c723ee67671ac3', 'result_count': 2}, {'issuer_ca_id': 183283, 'issuer_name': \"C=US, O=Let's Encrypt, CN=E1\", 'common_name': 'uproperties.com', 'name_value': 'uproperties.com', 'id': 12546462630, 'entry_timestamp': '2024-03-28T07:56:04.22', 'not_before': '2024-03-28T06:56:04', 'not_after': '2024-06-26T06:56:03', 'serial_number': '035c71a696301d4580f8a7c723ee67671ac3', 'result_count': 2}, {'issuer_ca_id': 183267, 'issuer_name': \"C=US, O=Let's Encrypt, CN=R3\", 'common_name': 'uproperties.com', 'name_value': 'uproperties.com', 'id': 12570950635, 'entry_timestamp': '2024-03-28T07:56:03.232', 'not_before': '2024-03-28T06:56:02', 'not_after': '2024-06-26T06:56:01', 'serial_number': '034bf52624602af5ba3a58627485ae3ecb93', 'result_count': 2}, {'issuer_ca_id': 183267, 'issuer_name': \"C=US, O=Let's Encrypt, CN=R3\", 'common_name': 'uproperties.com', 'name_value': 'uproperties.com', 'id': 12546462569, 'entry_timestamp': '2024-03-28T07:56:03.041', 'not_before': '2024-03-28T06:56:02', 'not_after': '2024-06-26T06:56:01', 'serial_number': '034bf52624602af5ba3a58627485ae3ecb93', 'result_count': 2}, {'issuer_ca_id': 183283, 'issuer_name': \"C=US, O=Let's Encrypt, CN=E1\", 'common_name': 'www.uproperties.com', 'name_value': 'www.uproperties.com', 'id': 12466318420, 'entry_timestamp': '2024-03-22T04:40:52.386', 'not_before': '2024-03-22T03:40:51', 'not_after': '2024-06-20T03:40:50', 'serial_number': '04f89429289fc840042cc8e8aef7ffcad2c0', 'result_count': 2}]"
    },
    {
        "thought": "The certificate information shows that the domain uproperties.com has a valid SSL certificate issued by Let's Encrypt, which is a widely recognized certificate authority. The certificate is recent and has not expired, which is a good sign for website security and legitimacy. With the information gathered so far, the website does not show any typical signs of a scam. It has a long-standing domain registration, a valid SSL certificate, and the content on the website appears to be consistent with legitimate business activity. I should conduct a final check to see how the website is perceived online through social media or community forums.",
        "action": "SearchReddit",
        "action_input": "\"United Properties\" \"uproperties.com\"",
        "observation": "[{'title': 'Code Blocks, in case GrandmaMax needs them.', 'subreddit': 'Hydroneer', 'url': 'https://www.reddit.com/r/Hydroneer/comments/urxhe0/code_blocks_in_case_grandmamax_needs_them/', 'selftext': \"Just so you know, these code blocks are copied over from Rama, on the Unreal discussion, where back in 2014, they figured out and wrote code samples that could be used in UE4 to do full physics over true multiplayer:  These are samples, obviously, and would need adapted, but it's code that has allowed other physics based type games to operate with a true multi player and not a pseudo type with split screen. The code was written for a simplistic multi player game with physics based around balls that had to traverse a course, but Rama notes that this can be modified to work for really any multi player game where physics is involved:\\n\\nRama writes:\\n\\nThere are three core concepts of my multiplayer physics implementation!\\n\\nThe use of VInterpTo to smoothly adjust the position of the non net owner, both physics position and physics linear velocity\\n\\nThe fact that player controlled units should never be interpolated, only the non-owner proxies of that player controlled unit should get interpolated.\\n\\nApply any additional forces requires to get the non owner to the owner’s position that include accounting for things like gravity.\\n\\n1 is how you ensure that the non owner proxy will always end up in the correct position, with an update speed that you can control and tailor to your needs via the interp speed. VInterpTo is also frame rate invariant which is essential for supporting different generations of hardware which will run the game at different frame rates.\\n\\n2 is about gameplay experience! You’d never want a client to feel like they had sluggish control or no control over their own player unit because the server is busy adjusting the client’s proxy to what the server thinks is correct. The local owner of the unit must have full control of the unit and update everyone else, including the server.\\n\\n3 is abount ensuring the physics replication will look good, by locally applying gravity and other forces to get the proxy back in sync with the net owner’s physics orientation\\n\\ncode blocks:\\n\\n>1.) \\n\\n    **Code Structure Sample**\\n\\n    .h\\n\\n\\n\\n    ```\\n\\n\\n    //This is basically a duplicate of the struct used by Actor.h for replication (wrote my own before I found out about FRepMovement)\\n\\n    /*\\n    UPROPERTY(Transient, ReplicatedUsing=OnRep_ReplicatedMovement)\\n    struct FRepMovement ReplicatedMovement;\\n    */\\n\\n    USTRUCT()\\nstruct FJoyMoveRep\\n    { \\n\\t    GENERATED_USTRUCT_BODY()\\n\\n\\t    UPROPERTY()\\n\\t    FVector_NetQuantize100 Location;\\n\\t\\n\\t    UPROPERTY()\\n\\t    FRotator Rotation;\\n\\t\\n\\t    UPROPERTY()\\n\\t    FVector_NetQuantize100 LinearVelocity;\\n\\t\\n\\t    UPROPERTY()\\n\\t    FVector_NetQuantize100 AngularVelocity;\\n\\t\\n\\t    FJoyMoveRep()\\n\\t    {\\n\\t\\t    Location = LinearVelocity = AngularVelocity = FVector::ZeroVector;\\n\\t\\t    Rotation = FRotator::ZeroRotator;\\n\\t    }\\n\\t    FJoyMoveRep(\\n\\t\\t    FVector_NetQuantize100 Loc, \\n\\t\\t    FRotator Rot,\\n\\t\\t    FVector_NetQuantize100 Vel,\\n\\t\\t    FVector_NetQuantize100 Angular\\n\\t    )\\t\\n\\t\\t    : Location(Loc)\\n\\t\\t    , Rotation(Rot)\\n\\t\\t    , LinearVelocity(Vel)\\n\\t\\t    , AngularVelocity(Angular)\\n\\t\\t\\n\\t    {}\\n    };\\n\\n\\n    UFUNCTION(Reliable,Server,WithValidation)\\n    void SERVER_SendJoyMove(FJoyMoveRep NewMove);\\n    bool SERVER_SendJoyMove_Validate(FJoyMoveRep NewMove);\\n    void SERVER_SendJoyMove_Implementation(FJoyMoveRep NewMove);\\n\\n\\n    //Interpolated by JoyMoveRep_Receive\\n    UPROPERTY(Replicated)\\n    FJoyMoveRep R_JoyMove;\\n\\n    //Guarantee Rep \\n    UPROPERTY(Replicated)\\n    uint8 DoRep_JoyMove;\\n\\n \\n    void JoyMoveReplication();\\n    void JoyMoveRep_Send();\\n    void JoyMoveRep_Receive();\\n\\n\\n    //class\\n\\n    UFUNCTION(Reliable,Server,WithValidation)\\n    void SERVER_SendJoyMove(FJoyMoveRep NewMove);\\n    bool SERVER_SendJoyMove_Validate(FJoyMoveRep NewMove);\\n    void SERVER_SendJoyMove_Implementation(FJoyMoveRep NewMove);\\n\\n    //Interpolated by JoyMoveRep_Receive\\n    UPROPERTY(Replicated)\\n    FJoyMoveRep R_JoyMove;\\n\\n    //Guarantee Rep \\n    UPROPERTY(Replicated)\\n    uint8 DoRep_JoyMove;\\n\\n\\n    ```\\n\\n2.) \\n\\n    void AJoyBallMovement::JoyMoveReplication()\\n    {   \\n\\t    if(IsLocallyControlled())\\n\\t    {\\n\\t\\t    JoyMoveRep_Send();\\n\\t    }\\n\\t    else\\n\\t    {\\n\\t\\t    //Update!\\n\\t\\t    JoyMoveRep_Receive();\\n\\t\\n\\t    }\\n    }\\n    void AJoyBallMovement::JoyMoveRep_Send()\\n    {\\n\\t    SERVER_SendJoyMove(\\n\\t\\t    FJoyMoveRep(\\n\\t\\t\\t    C_BodyLocation,\\n\\t\\t\\t    C_BodyRotation,\\n\\t\\t\\t    C_Velocity,\\n\\t\\t\\t    C_AngularVelocity\\n\\t\\t    )\\n\\t    );\\n    }\\t\\n    bool AJoyBallMovement::SERVER_SendJoyMove_Validate(FJoyMoveRep NewMove)\\n    {\\n\\t    return true;\\n    }\\n    void AJoyBallMovement::SERVER_SendJoyMove_Implementation(FJoyMoveRep NewMove)\\n    {\\n\\t    //Rep!\\n\\t    R_JoyMove = NewMove;  \\t//RepRetry\\n\\t    DoRep_JoyMove++;\\t\\t\\t//Just to guarantee rep happens\\n    }\\n\\n    //~~~\\n    //~~~\\n    //~~~\\n\\n    void AJoyBallMovement::JoyMoveRep_Receive()\\n    {\\n\\t    //Dont rep invalid data\\n\\t    if(R_JoyMove.Location.IsZero()) return;\\n\\t    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n\\t\\n\\t//implement what I outlined above, using VInterpTo to update PhysicsLinearVelocity and component location in world space\\n\\n       //Also you can interpolate rotation here, these are all vars that are part of R_JoyMove\\n      \\n       //This is the part that varies from project to project, which is why I outlined the core concepts above.\\n\\t\\n    }\\n\\n    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n    //\\t\\t\\t\\t\\t\\t\\tReplication List\\n    void AJoyBallHighest::GetLifetimeReplicatedProps( TArray< FLifetimeProperty > & OutLifetimeProps ) const\\n    { \\n\\t    Super::GetLifetimeReplicatedProps( OutLifetimeProps );\\n \\n\\t    //Joy Rep Physics Movement!\\n\\t    DOREPLIFETIME(AJoyBallHighest, JoyRepMoveVibes);\\n\\t    DOREPLIFETIME(AJoyBallHighest, DoRep_JoyRepMove);\\n    }\\n\\n     void AJoyBallMovement::Tick(float DeltaTime)\\n    {\\n\\tSuper::Tick(DeltaTime);\\n\\t//~~~~~~~~~~~~\\n\\t\\n\\t//Dont need to replicate movement in single player games\\n\\tif(GEngine->GetNetMode(GetWorld()) != NM_Standalone)\\n\\t{\\n                //Local owner updates others, \\n                //   others update every tick even when not getting data over network\\n\\t\\tJoyMoveReplication();\\n\\t}\\n    }\\n\\n\\n3.) \\n\\n**Notes on My Code Structure**\\n\\n**Please note I am deliberately not using ReplicatedUsing** because I need to call JoyMoveRep_Receive() every tick to apply extra forces like gravity locally and run the VInterpTo functions\\n\\nIf I used ReplicateUsing, the replication function would only get called when updates made it through across the real network, the infrequency of which is the precise reason I need to interpolate locally / apply physics forces locally.\\n\\nSince the R_JoyMove replication var is only getting updated based on real network conditions, I can use whatever data is stored there, from the last known update, and interpolate to correct postion and also account for local forces like gravity.\\n\\n**Also note that I check whether a unit is being locally controlled** to know whether it is sending updates or receiving them.\\n\\n\\n\\n    ```\\n\\n\\n    void AJoyBallMovement::JoyMoveReplication()\\n    {   \\n\\tif(IsLocallyControlled())\\n\\t{\\n\\t\\tJoyMoveRep_Send();\\n\\t}\\n\\telse\\n\\t{\\n\\t\\t//Update!\\n\\t\\tJoyMoveRep_Receive();\\n\\t\\n\\t}\\n    }\\n\\n\\n    ```\\n\\n\\n\\n    IsLocallyControlled() is part of Pawn class\\n\\n\\n \\n    ```\\n\\n\\n    bool APawn::IsLocallyControlled() const\\n    {\\n\\treturn ( Controller && Controller->IsLocalController() );\\n    }\\n\\n\\n    ```\\n\\n\\n\\nPlease note that this occurs every tick because I want to continue interpolating to last known network positions even when experiencing a laggy connection to the local owner. This is what VInterpTo does!\\n\\n\\n\\n\\nRama goes on to include the following code block to prevent cheating, noting that the code would force someone who is out of sync to default to the server host's information for future updates to the program:\\n\\n\\n    void AJoyBallMovement::JoyMoveReplication()\\n    {   \\n       //Add code here for Server sending cheating corrections\\n\\n\\tif(IsLocallyControlled() && !IsCheatingNeedToOverrideClientUpdates)\\n\\t{\\n\\t\\tJoyMoveRep_Send();\\n\\t}\\n\\telse\\n\\t{\\n\\t\\t//Update!\\n\\t\\tJoyMoveRep_Receive();  //if Cheating now even local gets updates from Server\\n\\t\\n\\t}\\n    }\\n\\n\\nThere is much more in the thread in regards to this, which can be found here:  https://forums.unrealengine.com/t/video-player-controlled-replicating-physics-movement-simulating-physics/7302/82  \\n\\nFor documentation and source purposes.\\n\\nAlso, to be clear, while I myself am not a coder (I am a 3D artist with 20+ years experience in 3Ds Max) I have worked in the past on other projects that require including physics systems with online multiplayer in the UE4 engine, and have needed to do testing and trouble shooting on the fly in a development environment where changes were being made and I was testing the result.\\n\\n\\nNote due to Reddit formatting issues, it's making the code blocks look weird. will address with edits to correct.\", 'comments': ['Very cool :D', 'Isnt replicating location built in? This was last updated in 2016, not 2022.']}, {'title': 'Trying to solve the issues I have with rotation matrices and quaternions', 'subreddit': 'unrealengine', 'url': 'https://www.reddit.com/r/unrealengine/comments/lbg6xy/trying_to_solve_the_issues_i_have_with_rotation/', 'selftext': 'Hello guys!\\n\\nFirst of all. this is a big post, so I apologize for its size. Sorry for my bad grammar, its 3:00 am here and I\\'m sleepy.\\n\\nI\\'m expanding my skill mechanic and I\\'ve tried to use both quaternions and affine transformations/rotation matrices to do the job, using my mathematical knowledge I\\'ve learned long ago, on my university.\\n\\nBased on the facts that quaternions are 4D vectors extended from i-numbers that should be normalized before multiply them with any vectors or generate any kind of rotation matrix (because we must bring it back to the unit sphere in the 3D Euclidean space) and the multiplication between two vectors results in a perpendicular vector (result of a cross product) that not necessarily is a unit vector and should be normalized, among other things, I tried to make an actor, captured by black hole skill, initiate an elliptic orbit around its captor.\\n\\nElliptic orbits were calculated, initially, based on the ellipse parametric equation (the FVector NextLocation = (...) part, lines 468 - 477). As you can see in the video, it works relatively well, except for ONE PROBLEM: the orbiting actor was supposed to start orbiting in the position (SkillLocation.X + radius \\\\* Cos(XYAngle), SkillLocation.Y + radius \\\\* Sin(XYAngle), SkillLocation.Z), the XYAngle is calculated in the ABlackHoleSkill::GenerateOrbitData() method), but, as you can see, is way off, In the video, the orange line is used to mark the (constant\\\\*cos(0),0,0), the magenta to mark the (0,constant\\\\*c sin(90),0), the cyan marking the (constant\\\\*ccos(180),0,0), and the yellow marking the (0,constant\\\\*csin(270),0), for visual debug purpose, as well the white line, marking the vector point to the orbiting actor initial location. I\\'d appreciate if someone tell me my mistake here.\\n\\nSecond, I tried, inside the GenerateOrbitData method, to project the PullDirection vector on the planes XY XZ and YZ, and to find the angles between these projections and the skill\\'s forward and right vectors, respectively. Once I\\'ve got these values, I increased them by a specific value and used them on rotation matrices (basically making use of Euler angles), but I didn\\'t get the result I was expecting. I just left the Z axis rotation matrix uncommented, to rotate the orbiting actor on the XY plane, like the parametric equation used ealier. I tried this to make the captured actor orbit not only on XY plane, but any plane, around the skill.\\n\\nHere is the video: [https://www.youtube.com/watch?v=aZnxhx0tD3o&feature=youtu.be](https://www.youtube.com/watch?v=aZnxhx0tD3o&feature=youtu.be)\\n\\nAnd here is the code:\\n\\n.h\\n\\n    // Fill out your copyright notice in the Description page of Project Settings.\\n    \\n    #pragma once\\n    \\n    #include \"CoreMinimal.h\"\\n    #include \"GameFramework/Actor.h\"\\n    #include \"BlackHoleSkill.generated.h\"\\n    \\n    class UNiagaraSystem;\\n    class UNiagaraComponent;\\n    class UProjectileMovementComponent;\\n    class USphereComponent;\\n    \\n    namespace EPlane{\\n    \\t\\n    \\tUENUM()\\n    \\tenum Type\\n    \\t{\\t\\t\\n    \\t\\tYZ,\\n    \\t\\tXZ,\\n    \\t\\tXY\\n    \\t};\\n    \\n    }\\n    \\n    USTRUCT(BlueprintType)\\n    struct FBlackHoleOrbitData  \\n    {\\n    \\tGENERATED_BODY()\\n    \\t\\n    \\tUPROPERTY()\\n    \\tfloat MajorOrbitRadius;\\t\\n    \\n    \\tUPROPERTY()\\n    \\tbool OrbitFlag = false;\\n    \\n    \\tUPROPERTY()\\n    \\tuint32 OrbitID;\\n    \\n    \\tUPROPERTY()\\n    \\tFQuat OrbitOrientation;\\n    \\n    \\tUPROPERTY()\\n    \\tTArray<float> RotationAngleArr;\\n    \\n    \\tUPROPERTY()\\n    \\tfloat YZAngle;\\n    \\n    \\tUPROPERTY()\\n    \\tfloat XYAngle;\\n    \\n    \\tUPROPERTY()\\n    \\tfloat XZAngle;\\n    \\n    public:\\n    \\t\\n    \\tFBlackHoleOrbitData(){}\\n    \\n    };\\n    \\n    UCLASS()\\n    class PRJ_PROJECTILETESTEX_API ABlackHoleSkill : public AActor\\n    {\\n    \\tGENERATED_BODY()\\n    \\t\\n    \\tUPROPERTY(EditDefaultsOnly, Category = \"Properties\", meta = (AllowPrivateAccess = \"true\"))\\n    \\tUStaticMeshComponent* BlackHoleEventHorizon;\\n    \\n    \\tUPROPERTY(VisibleDefaultsOnly, Category = \"Properties\", meta = (AllowPrivateAccess = \"true\"))\\n    \\tUSphereComponent* BlackHoleGravitationalInfluenceSpace;\\n    \\n    \\tUPROPERTY(EditDefaultsOnly, Category = \"Properties\", meta = (AllowPrivateAccess = \"true\"))\\n    \\tfloat BlackHoleInitialSpeed;\\n    \\n    \\tUPROPERTY(EditDefaultsOnly, Category = \"Properties\", meta = (AllowPrivateAccess = \"true\"))\\n    \\tfloat BlackHoleMaxSpeed;\\n    \\n    \\tUPROPERTY(EditDefaultsOnly, Category = \"Properties\", meta = (AllowPrivateAccess = \"true\"))\\n    \\tfloat BlackHolePullForce; \\t\\n    \\n    \\tUPROPERTY(EditDefaultsOnly, Category = \"Visual Effects\", meta = (AllowPrivateAccess = \"true\"))\\n    \\tUNiagaraSystem* BlackHoleVFX;\\n    \\n    \\tUPROPERTY()\\n    \\tUNiagaraComponent* BlackHoleVFXComp;\\n    \\n    \\tUPROPERTY()\\n    \\tUProjectileMovementComponent* BlackHoleMovementComp;\\t\\n    \\t\\t\\n    \\tbool Compare(TArray<UPrimitiveComponent*> Arr1, TArray<UPrimitiveComponent*> Arr2);\\n    \\n    \\tUPROPERTY(EditDefaultsOnly, Category = \"Properties\", meta = (AllowPrivateAccess = \"true\"))\\n    \\tfloat EllipticalMovementRate;\\n    \\n    \\tFBlackHoleOrbitData GenerateOrbitData(UPrimitiveComponent* OverlappedComponent);\\n    \\t\\n    \\tUPROPERTY(EditDefaultsOnly, Category = \"Properties\", meta = (AllowPrivateAccess = \"true\"))\\n    \\tfloat MajorEllipticOrbitFraction;\\n    \\n    \\tUPROPERTY()\\n    \\tTArray<FBlackHoleOrbitData> OrbitDataArr;\\t\\n    \\n    \\tUPROPERTY()\\n    \\tTArray<UPrimitiveComponent*> PreviouslyOverlapppedComponentArr;\\t\\n    \\n    public:\\n    \\t// Sets default values for this actor\\'s properties\\n    \\tABlackHoleSkill(const FObjectInitializer& ObjectInitializer);\\n    \\n    protected:\\n    \\t// Called when the game starts or when spawned\\n    \\tvirtual void BeginPlay() override;\\n    \\n    \\tvoid DrawSecondaryHelpers(const FVector& BlackHoleLocation, const FVector& OrbitingActorLocation, const FBlackHoleOrbitData& NewOrbitData);\\n    \\n    \\tvoid DrawPrimaryHelpers(const FVector& BlackHoleLocation);\\n    \\t\\n    \\tvirtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;\\n    \\n    \\tfloat GetAngleBetween(const FVector& Vec1, const FVector& Vec2, EPlane::Type ProjectionPlane);\\n    \\n    public:\\n    \\tvoid MoveInDirection(FVector Direction);\\t\\n    \\n    \\tvirtual void PostInitializeComponents();\\n    \\n    \\t// Called every frame\\n    \\tvirtual void Tick(float DeltaTime) override;\\n    \\n    };\\n\\n.cpp\\n\\n    // Fill out your copyright notice in the Description page of Project Settings.\\n    \\n    \\n    #include \"BlackHoleSkill.h\"\\n    #include \"Components/SphereComponent.h\"\\n    #include \"Gameframework/ProjectileMovementComponent.h\"\\n    #include \"GameFramework/Character.h\"\\n    #include \"Engine/SkeletalMeshSocket.h\"\\n    #include \"PRJ_ProjectileTestEXCharacter.h\"\\n    #include \"NiagaraSystem.h\"\\n    #include \"NiagaraComponent.h\"\\n    #include \"NiagaraFunctionLibrary.h\"\\n    #include \"DrawDebugHelpers.h\"\\n    #include \"ProjectileTestEXConstants.h\"\\n    #include \"Kismet/KismetMathLibrary.h\"\\n    #include \"SortingAlgorithmsInterface.h\"\\n    #include \"SearchingAlgorithmsInterface.h\"\\n    #include \"Math/Axis.h\" \\n    \\n    // Sets default values\\n    ABlackHoleSkill::ABlackHoleSkill(const FObjectInitializer& ObjectInitializer)\\n    {\\n    \\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don\\'t need it.\\n    \\tPrimaryActorTick.bCanEverTick = true;\\t\\n    \\n    \\tBlackHoleGravitationalInfluenceSpace = ObjectInitializer.CreateDefaultSubobject<USphereComponent>(this, TEXT(\"BlackHoleGravitationalInfluenceSpace\"));\\n    \\tBlackHoleGravitationalInfluenceSpace->SetSphereRadius(500);\\n    \\tBlackHoleGravitationalInfluenceSpace->SetCollisionEnabled(ECollisionEnabled::QueryOnly);\\t\\n    \\tFCollisionResponseContainer CollisionResponseContainer = FCollisionResponseContainer(ECollisionResponse::ECR_Ignore);\\n    \\tCollisionResponseContainer.SetResponse(ECollisionChannel::ECC_PhysicsBody, ECollisionResponse::ECR_Overlap);\\t\\n    \\tBlackHoleGravitationalInfluenceSpace->SetCollisionResponseToChannels(CollisionResponseContainer);\\n    \\tBlackHoleGravitationalInfluenceSpace->SetGenerateOverlapEvents(true);\\n    \\tBlackHoleGravitationalInfluenceSpace->SetSimulatePhysics(false);\\t\\n    \\tRootComponent = BlackHoleGravitationalInfluenceSpace;\\n    \\t\\n    \\tBlackHoleVFXComp = ObjectInitializer.CreateDefaultSubobject<UNiagaraComponent>(this, TEXT(\"BlackHoleVFX\"));\\n    \\tBlackHoleVFXComp->SetupAttachment(RootComponent);\\n    \\n    \\tBlackHoleMovementComp = ObjectInitializer.CreateDefaultSubobject<UProjectileMovementComponent>(this, TEXT(\"BlackHoleMovementComp\"));\\n    \\tBlackHoleMovementComp->SetUpdatedComponent(BlackHoleGravitationalInfluenceSpace);\\t\\n    \\tBlackHoleMovementComp->bRotationFollowsVelocity = true;\\t\\n    \\tBlackHoleMovementComp->bShouldBounce = false;\\n    \\tBlackHoleMovementComp->ProjectileGravityScale = 0.f;\\n    \\n    }\\n    \\n    // Called when the game starts or when spawned\\n    void ABlackHoleSkill::BeginPlay()\\n    {\\n    \\tSuper::BeginPlay();\\t\\n    \\t\\n    \\tSetLifeSpan(5.f);\\n    \\tUE_LOG(LogTemp, Warning, TEXT(\"Actor lifespan = %f\"), InitialLifeSpan);\\n    \\tif (BlackHoleVFX)\\n    \\t{\\t\\t\\n    \\t\\tACharacter* BlackHoleOwner = Cast<ACharacter>(GetOwner());\\t\\t\\n    \\t\\tif (BlackHoleOwner)\\n    \\t\\t{\\t\\t\\t\\n    \\t\\t\\tBlackHoleVFXComp = UNiagaraFunctionLibrary::SpawnSystemAttached(\\n    \\t\\t\\t\\tBlackHoleVFX,\\n    \\t\\t\\t\\tRootComponent,\\n    \\t\\t\\t\\tFName(\"BlackHoleVFX\"),\\n    \\t\\t\\t\\tBlackHoleOwner->GetMesh()->GetSocketLocation(\"hand_r\"),\\n    \\t\\t\\t\\tGetActorForwardVector().ToOrientationRotator(),\\n    \\t\\t\\t\\tEAttachLocation::KeepWorldPosition,\\n    \\t\\t\\t\\tfalse\\n    \\t\\t\\t);\\n    \\t\\t}\\n    \\t}\\n    \\t\\n    }\\n    \\n    bool ABlackHoleSkill::Compare(TArray<UPrimitiveComponent*> Arr1, TArray<UPrimitiveComponent*> Arr2)\\n    {\\n    \\tbool IsEqual = false;\\n    \\tif(Arr1.Num() == Arr2.Num())\\n    \\t{\\n    \\t\\tIsEqual = true;\\n    \\t\\tfor(int Index = 0; Index <= Arr1.Num() - 1; Index++)\\n    \\t\\t{\\n    \\t\\t\\tif(Arr1[Index]->GetUniqueID() != Arr2[Index]->GetUniqueID())\\n    \\t\\t\\t{\\n    \\t\\t\\t\\tIsEqual = false;\\n    \\t\\t\\t\\treturn IsEqual;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\n    \\treturn IsEqual;\\n    \\n    }\\n    \\n    void ABlackHoleSkill::DrawSecondaryHelpers(const FVector& BlackHoleLocation, const FVector& OrbitingActorLocation, const FBlackHoleOrbitData& NewOrbitData)\\n    {\\n    \\tDrawDebugLine(\\n    \\t\\tGetWorld(),\\n    \\t\\tBlackHoleLocation,\\n    \\t\\tBlackHoleLocation + FVector(NewOrbitData.MajorOrbitRadius, 0, 0) * .5,\\n    \\t\\tFColor::Black,\\n    \\t\\tfalse,\\n    \\t\\t5.f,\\n    \\t\\t0,\\n    \\t\\t2.f\\n    \\t);\\n    \\tDrawDebugLine(\\n    \\t\\tGetWorld(),\\n    \\t\\tBlackHoleLocation,\\n    \\t\\tOrbitingActorLocation,\\n    \\t\\tFColor::Turquoise,\\n    \\t\\tfalse,\\n    \\t\\t5.f,\\n    \\t\\t0,\\n    \\t\\t2.f\\n    \\t);\\n    \\tDrawDebugSphere(\\n    \\t\\tGetWorld(),\\n    \\t\\tFVector(\\n    \\t\\t\\tBlackHoleLocation.X + (NewOrbitData.MajorOrbitRadius *\\n    \\t\\t\\t\\tFMath::Cos(NewOrbitData.XYAngle)\\n    \\t\\t\\t\\t),\\n    \\t\\t\\tBlackHoleLocation.Y + ((NewOrbitData.MajorOrbitRadius *\\n    \\t\\t\\t\\tMajorEllipticOrbitFraction) *\\n    \\t\\t\\t\\tFMath::Sin(NewOrbitData.XYAngle)\\n    \\t\\t\\t\\t),\\n    \\t\\t\\tBlackHoleLocation.Z\\n    \\t\\t),\\n    \\t\\t10,\\n    \\t\\t20,\\n    \\t\\tFColor::Red,\\n    \\t\\tfalse,\\n    \\t\\t5.f,\\n    \\t\\t0,\\n    \\t\\t2.f\\n    \\t);\\n    \\tFVector PullDirection = BlackHoleLocation - OrbitingActorLocation;\\t\\n    \\tDrawDebugLine(\\n    \\t\\tGetWorld(),\\n    \\t\\tBlackHoleLocation,\\n    \\t\\tBlackHoleLocation + (-PullDirection),\\t\\t\\n    \\t\\tFColor::Red,\\n    \\t\\tfalse,\\n    \\t\\t3.5f,\\n    \\t\\t0,\\n    \\t\\t2.f\\n    \\t);\\n    \\n    }\\n    \\n    void ABlackHoleSkill::DrawPrimaryHelpers(const FVector& BlackHoleLocation)\\n    {\\n    \\tDrawDebugSphere(\\n    \\t\\tGetWorld(),\\n    \\t\\tBlackHoleLocation,\\n    \\t\\tBlackHoleGravitationalInfluenceSpace->GetScaledSphereRadius(),\\n    \\t\\t20,\\n    \\t\\tFColor::Red,\\n    \\t\\tfalse,\\n    \\t\\t.1f,\\n    \\t\\t0,\\n    \\t\\t2.f\\n    \\t);\\n    \\tDrawDebugLine(\\n    \\t\\tGetWorld(),\\n    \\t\\tBlackHoleLocation,\\n    \\t\\tBlackHoleLocation + GetActorForwardVector() * 100,\\n    \\t\\tFColor::Green,\\n    \\t\\tfalse,\\n    \\t\\t0.1f,\\n    \\t\\t0,\\n    \\t\\t2.f\\n    \\t);\\t\\n    \\tDrawDebugLine(\\n    \\t\\tGetWorld(),\\n    \\t\\tBlackHoleLocation,\\n    \\t\\tBlackHoleLocation + FVector(50, 0, 0),\\n    \\t\\tFColor::Orange,\\n    \\t\\tfalse,\\n    \\t\\t0.1f,\\n    \\t\\t0,\\n    \\t\\t2.f\\n    \\t);\\n    \\tDrawDebugSphere(\\n    \\t\\tGetWorld(),\\n    \\t\\tBlackHoleLocation + FVector(50, 0, 0),\\n    \\t\\t5,\\n    \\t\\t20,\\n    \\t\\tFColor::Orange,\\n    \\t\\tfalse,\\n    \\t\\t.1f,\\n    \\t\\t0,\\n    \\t\\t2.f\\n    \\t);\\n    \\tDrawDebugLine(\\n    \\t\\tGetWorld(),\\n    \\t\\tBlackHoleLocation,\\n    \\t\\tBlackHoleLocation + FVector(0, 50, 0),\\n    \\t\\tFColor::Magenta,\\n    \\t\\tfalse,\\n    \\t\\t0.1f,\\n    \\t\\t0,\\n    \\t\\t2.f\\n    \\t);\\n    \\tDrawDebugSphere(\\n    \\t\\tGetWorld(),\\n    \\t\\tBlackHoleLocation + FVector(0, 50, 0),\\n    \\t\\t5,\\n    \\t\\t20,\\n    \\t\\tFColor::Magenta,\\n    \\t\\tfalse,\\n    \\t\\t.1f,\\n    \\t\\t0,\\n    \\t\\t2.f\\n    \\t);\\n    \\tDrawDebugLine(\\n    \\t\\tGetWorld(),\\n    \\t\\tBlackHoleLocation,\\n    \\t\\tBlackHoleLocation + FVector(-50, 0, 0),\\n    \\t\\tFColor::Cyan,\\n    \\t\\tfalse,\\n    \\t\\t0.1f,\\n    \\t\\t0,\\n    \\t\\t2.f\\n    \\t);\\n    \\tDrawDebugSphere(\\n    \\t\\tGetWorld(),\\n    \\t\\tBlackHoleLocation + FVector(-50, 0, 0),\\n    \\t\\t5,\\n    \\t\\t20,\\n    \\t\\tFColor::Cyan,\\n    \\t\\tfalse,\\n    \\t\\t.1f,\\n    \\t\\t0,\\n    \\t\\t2.f\\n    \\t);\\n    \\tDrawDebugLine(\\n    \\t\\tGetWorld(),\\n    \\t\\tBlackHoleLocation,\\n    \\t\\tBlackHoleLocation + FVector(0, -50, 0),\\n    \\t\\tFColor::Yellow,\\n    \\t\\tfalse,\\n    \\t\\t0.1f,\\n    \\t\\t0,\\n    \\t\\t2.f\\n    \\t);\\n    \\tDrawDebugSphere(\\n    \\t\\tGetWorld(),\\n    \\t\\tBlackHoleLocation + FVector(0, -50, 0),\\n    \\t\\t5,\\n    \\t\\t20,\\n    \\t\\tFColor::Yellow,\\n    \\t\\tfalse,\\n    \\t\\t.1f,\\n    \\t\\t0,\\n    \\t\\t2.f\\n    \\t);\\n    \\n    }\\n    \\n    FBlackHoleOrbitData ABlackHoleSkill::GenerateOrbitData(UPrimitiveComponent* OverlappedComponent)\\n    {\\n    \\tFBlackHoleOrbitData NewOrbitData = FBlackHoleOrbitData();\\n    \\tNewOrbitData.OrbitID = OverlappedComponent->GetUniqueID();\\n    \\tFVector BlackHoleLocation = GetActorLocation();\\n    \\tFVector OrbitingActorLocation = OverlappedComponent->GetOwner()->GetActorLocation();\\n    \\tFVector PullDirection = BlackHoleLocation - OrbitingActorLocation;\\n    \\tPullDirection.Normalize();\\n    \\tNewOrbitData.MajorOrbitRadius = FVector::Dist(BlackHoleLocation, OrbitingActorLocation);\\t\\n    \\tFVector InitialEllipticPos = BlackHoleLocation + FVector(NewOrbitData.MajorOrbitRadius, 0, 0);\\n    \\tInitialEllipticPos.Normalize();\\n    \\t//NewOrbitData.XYAngle = GetAngleBetween(InitialEllipticPos, -PullDirection, EPlane::XY);\\n    \\tNewOrbitData.YZAngle = GetAngleBetween(GetActorRightVector(), -PullDirection, EPlane::YZ);\\n    \\tNewOrbitData.XZAngle = GetAngleBetween(GetActorForwardVector(), -PullDirection, EPlane::XZ);\\n    \\tNewOrbitData.XYAngle = GetAngleBetween(GetActorForwardVector(), -PullDirection, EPlane::XY);\\n    \\tNewOrbitData.OrbitOrientation = GetActorRotation().Quaternion();\\t\\n    \\tFQuat OrientationQuat = FQuat::Identity;\\t\\n    \\tfloat w, i, j, k;\\n    \\ti = j = k = 0.f;\\n    \\tw = 1.f;\\n    \\tFRandomStream RandomStream = FRandomStream(FMath::Rand());\\t\\n    \\tint32 InputQuantity = RandomStream.RandRange(0, 3);\\t\\n    \\tswitch(InputQuantity)\\n    \\t{\\n    \\t\\tcase 0: {\\t\\t\\t\\t\\t\\n    \\t\\t\\t\\t\\ti = RandomStream.FRandRange(-1.f, 1.f);\\t\\t\\t\\t\\t\\n    \\t\\t\\t\\t  }\\n    \\t\\t\\t\\t  break;\\n    \\t\\tcase 1: {\\t\\t\\t\\t\\t\\n    \\t\\t\\t\\t\\ti = RandomStream.FRandRange(-1.f, 1.f);\\n    \\t\\t\\t\\t\\tj = RandomStream.FRandRange(-1.f, 1.f);\\t\\t\\t\\t\\t\\n    \\t\\t\\t\\t  }\\n    \\t\\t\\t\\t  break;\\n    \\t\\tcase 2: {\\t\\t\\t\\t\\t\\n    \\t\\t\\t\\t\\ti = RandomStream.FRandRange(-1.f, 1.f);\\n    \\t\\t\\t\\t\\tj = RandomStream.FRandRange(-1.f, 1.f);\\n    \\t\\t\\t\\t\\tk = RandomStream.FRandRange(-1.f, 1.f);\\t\\t\\t\\t\\t\\n    \\t\\t\\t\\t  }\\n    \\t\\t\\t\\t  break;\\n    \\t\\tcase 3: {\\n    \\t\\t\\t\\t\\ti = RandomStream.FRandRange(-1.f, 1.f);\\n    \\t\\t\\t\\t\\tj = RandomStream.FRandRange(-1.f, 1.f);\\n    \\t\\t\\t\\t\\tk = RandomStream.FRandRange(-1.f, 1.f);\\n    \\t\\t\\t\\t\\tw = RandomStream.FRandRange(-1.f, 1.f);\\t\\t\\t\\t\\t\\n    \\t\\t\\t\\t  }\\n    \\t\\t\\t\\t  break;\\n    \\t\\tdefault: break;\\t\\t\\t\\t\\t\\n    \\t}\\t\\t\\n    \\tOrientationQuat = FQuat(i, j, k, w);\\t\\n    \\tNewOrbitData.OrbitOrientation *= OrientationQuat;\\t\\t\\t\\n    \\tNewOrbitData.OrbitOrientation.Normalize();\\n    \\tUE_LOG(LogTemp, Warning, TEXT(\"Is the quaternion generated during the capture identity? %s\"),\\n    \\t\\tNewOrbitData.OrbitOrientation.IsIdentity() ? TEXT(\"It is\") : TEXT(\"It isn\\'t\")\\n    \\t);\\n    \\tInputQuantity = RandomStream.RandRange(0, 2);\\n    \\tfor(int Index = 0; Index <= InputQuantity; Index++)\\n    \\t{\\n    \\t\\tNewOrbitData.RotationAngleArr.Add(RandomStream.FRandRange(0, 360));\\n    \\t\\tUE_LOG(LogTemp, Warning, TEXT(\"RotationAngleArr[%d] = %f\"),\\n    \\t\\t\\tIndex,\\n    \\t\\t\\tNewOrbitData.RotationAngleArr[Index]\\n    \\t\\t);\\n    \\t}\\t\\n    \\tNewOrbitData.OrbitFlag = true;\\n    \\tUE_LOG(LogTemp, Warning, TEXT(\"<CAPTURE DATA> Orbit ID = %d\\\\t\\\\tNegative angle = %s\\\\t\\\\tOrbit Angle = %f\"),\\n    \\t\\tNewOrbitData.OrbitID,\\t\\n    \\t\\t(NewOrbitData.XYAngle < 0) ? TEXT(\"true\") : TEXT(\"false\"),\\n    \\t\\tNewOrbitData.XYAngle\\n    \\t);\\n    \\tDrawSecondaryHelpers(BlackHoleLocation, OrbitingActorLocation, NewOrbitData);\\t\\n    \\t\\n    \\treturn NewOrbitData;\\n    }\\n    \\n    void ABlackHoleSkill::EndPlay(const EEndPlayReason::Type EndPlayReason)\\n    {\\n    \\tSuper::EndPlay(EndPlayReason);\\n    \\n    \\tif (PreviouslyOverlapppedComponentArr.Num() > 0)\\n    \\t{\\n    \\t\\tfor (UPrimitiveComponent* PreviouslyOverlappedComponent : PreviouslyOverlapppedComponentArr)\\n    \\t\\t{\\t\\t\\t\\n    \\t\\t\\tPreviouslyOverlappedComponent->SetEnableGravity(true);\\t\\t\\t\\n    \\t\\t}\\n    \\t}\\n    }\\n    \\n    float ABlackHoleSkill::GetAngleBetween(const FVector& Vec1, const FVector& Vec2, EPlane::Type ProjectionPlane)\\n    {\\n    \\tFVector2D ProjectedVec1, ProjectedVec2;\\n    \\tfloat AngleBetween;\\n    \\t\\n    \\tif(ProjectionPlane == EPlane::YZ)\\n    \\t{\\t\\t\\n    \\t\\tProjectedVec1 = FVector2D(Vec1.Y, Vec1.Z);\\n    \\t\\tProjectedVec2 = FVector2D(Vec2.Y, Vec2.Z);\\n    \\t}\\n    \\telse\\n    \\t{\\n    \\t\\tif(ProjectionPlane == EPlane::XZ)\\n    \\t\\t{\\n    \\t\\t\\tProjectedVec1 = FVector2D(Vec1.X, Vec1.Z);\\n    \\t\\t\\tProjectedVec2 = FVector2D(Vec2.X, Vec2.Z);\\n    \\t\\t}\\n    \\t\\telse\\n    \\t\\t{\\n    \\t\\t\\tProjectedVec1 = FVector2D(Vec1.X, Vec1.Y);\\n    \\t\\t\\tProjectedVec2 = FVector2D(Vec2.X, Vec2.Y);\\n    \\t\\t}\\n    \\t}\\t\\n    \\tAngleBetween = UKismetMathLibrary::RadiansToDegrees(\\n    \\t\\tUKismetMathLibrary::Acos(\\n    \\t\\t\\tFVector2D::DotProduct(\\n    \\t\\t\\t\\tProjectedVec1,\\n    \\t\\t\\t\\tProjectedVec2\\n    \\t\\t\\t) /\\n    \\t\\t\\t(ProjectedVec1.Size() * ProjectedVec2.Size())\\n    \\t\\t)\\n    \\t);\\n    \\tif (FVector2D::CrossProduct(ProjectedVec1, ProjectedVec2) < 0)\\n    \\t{\\n    \\t\\tAngleBetween = -AngleBetween;\\n    \\t}\\n    \\n    \\treturn AngleBetween;\\n    \\n    }\\n    \\n    void ABlackHoleSkill::MoveInDirection(FVector Direction)\\n    {\\n    \\tBlackHoleMovementComp->Velocity = Direction * BlackHoleMovementComp->InitialSpeed;\\n    }\\n    \\n    void ABlackHoleSkill::PostInitializeComponents()\\n    {\\n    \\tSuper::PostInitializeComponents();\\t\\n    \\n    \\tBlackHoleMovementComp->InitialSpeed = BlackHoleInitialSpeed;\\n    \\tBlackHoleMovementComp->MaxSpeed = BlackHoleMaxSpeed;\\n    \\n    }\\n    \\n    // Called every frame\\n    void ABlackHoleSkill::Tick(float DeltaTime)\\n    {\\n    \\tSuper::Tick(DeltaTime);\\n    \\n    \\tFVector BlackHoleLocation = GetActorLocation();\\n    \\tDrawPrimaryHelpers(BlackHoleLocation);\\n    \\tTArray<UPrimitiveComponent*> OverlappedComponentArr;\\t\\n    \\tGetOverlappingComponents(OverlappedComponentArr);\\n    \\tTArray<UPrimitiveComponent*> TempArr;\\n    \\tfor(UPrimitiveComponent* OverlappedComponent : OverlappedComponentArr)\\n    \\t{\\n    \\t\\tif(OverlappedComponent->GetOwner()->GetClass() != ACharacter::StaticClass())\\n    \\t\\t{\\n    \\t\\t\\tTempArr.Add(OverlappedComponent);\\n    \\t\\t}\\n    \\t}\\t\\n    \\tISortingAlgorithmsInterface::RandomizedQuickSort(TempArr, 0, TempArr.Num() - 1);\\t\\t\\n    \\tif(!Compare(TempArr, PreviouslyOverlapppedComponentArr) && TempArr.Num() > 0) \\n    \\t{\\n    \\t\\tfor(int Index = 0; Index <= TempArr.Num() - 1; Index++)\\n    \\t\\t{\\n    \\t\\t\\tif(OrbitDataArr.Num() == 0 || Index > OrbitDataArr.Num() - 1)\\n    \\t\\t\\t{\\n    \\t\\t\\t\\tOrbitDataArr.Add(GenerateOrbitData(TempArr[Index]));\\n    \\t\\t\\t}\\n    \\t\\t\\telse\\n    \\t\\t\\t{\\n    \\t\\t\\t\\tif(Index <= OrbitDataArr.Num() - 1 && (OrbitDataArr[Index].OrbitID != TempArr[Index]->GetUniqueID()))\\n    \\t\\t\\t\\t{\\n    \\t\\t\\t\\t\\tOrbitDataArr.Insert(GenerateOrbitData(TempArr[Index]), Index);\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\t\\n    \\tFMatrix XAxisRotation, YAxisRotation, ZAxisRotation;\\n    \\tFMatrix XYZToWorldOrigin, XYZToBlackHole, XYZTransformation;\\n    \\tFVector4 XYZVec, TransformedVec;\\n    \\tXAxisRotation = YAxisRotation = ZAxisRotation = FMatrix::Identity;\\n    \\tXYZToWorldOrigin = XYZToBlackHole = XYZTransformation = FMatrix::Identity;\\n    \\tXYZVec = TransformedVec = FVector4();\\n    \\n    \\tfor(int Index = 0; Index <= TempArr.Num() - 1; Index++)\\n    \\t{\\n    \\t\\tif (TempArr[Index]->IsGravityEnabled())\\n    \\t\\t{\\n    \\t\\t\\tTempArr[Index]->SetEnableGravity(false);\\n    \\t\\t}\\n    \\t\\tUE_LOG(LogTemp, Warning, TEXT(\"<MOVEMENT DATA> Orbit ID = %d\\\\t\\\\tOrbit Angle = %f\"),\\n    \\t\\t\\tOrbitDataArr[Index].OrbitID,\\n    \\t\\t\\tOrbitDataArr[Index].XYAngle\\n    \\t\\t);\\t\\t\\n    \\t\\tif (OrbitDataArr[Index].OrbitFlag)\\n    \\t\\t{\\n    \\t\\t\\tDrawDebugLine(\\n    \\t\\t\\t\\tGetWorld(),\\n    \\t\\t\\t\\tBlackHoleLocation,\\n    \\t\\t\\t\\tTempArr[Index]->GetOwner()->GetActorLocation(),\\n    \\t\\t\\t\\tFColor::White,\\n    \\t\\t\\t\\tfalse,\\n    \\t\\t\\t\\tInitialLifeSpan / 2,\\n    \\t\\t\\t\\t0,\\n    \\t\\t\\t\\t2.f\\n    \\t\\t\\t);\\n    \\t\\t\\tOrbitDataArr[Index].OrbitFlag = false;\\n    \\t\\t}\\n    \\t\\tOrbitDataArr[Index].XYAngle += EllipticalMovementRate;\\n    \\t\\t//FVector BlackHoleLocation = GetActorLocation();\\n    \\t\\tFVector NextLocation = FVector(\\n    \\t\\t\\tBlackHoleLocation.X + (OrbitDataArr[Index].MajorOrbitRadius *\\n    \\t\\t\\t\\t\\t\\t\\t\\t   FMath::Cos(OrbitDataArr[Index].XYAngle)\\n    \\t\\t\\t\\t\\t\\t\\t\\t  ),\\n    \\t\\t\\tBlackHoleLocation.Y + ((OrbitDataArr[Index].MajorOrbitRadius *\\n    \\t\\t\\t\\t\\t\\t\\t\\t\\tMajorEllipticOrbitFraction) *\\n    \\t\\t\\t\\t\\t\\t\\t\\t   FMath::Sin(OrbitDataArr[Index].XYAngle)\\n    \\t\\t\\t\\t\\t\\t\\t\\t  ),\\n    \\t\\t\\tBlackHoleLocation.Z\\n    \\t\\t);\\n    \\t\\t//TempArr[Index]->GetOwner()->SetActorLocation(NextLocation);\\n    \\t\\t//TempArr[Index]->GetOwner()->SetActorRelativeLocation(BlackHoleLocation);\\n    \\t\\t//TempArr[Index]->GetOwner()->SetActorRelativeRotation(OrbitDataArr[Index].OrbitOrientation);\\n    \\t\\t\\n    \\t\\tUE_LOG(LogTemp, Warning, TEXT(\"Creating the rotation matrices...\"));\\n    \\t\\tFVector OrbitingActorLocation = TempArr[Index]->GetOwner()->GetActorLocation();\\n    \\t\\tFVector OrbitingActorRotation = TempArr[Index]->GetOwner()->GetActorRotation().Vector();\\n    \\t\\tXYZToWorldOrigin = FMatrix(\\n    \\t\\t\\tFPlane(1, 0, 0, -BlackHoleLocation.X),\\n    \\t\\t\\tFPlane(0, 1, 0, -BlackHoleLocation.Y),\\n    \\t\\t\\tFPlane(0, 0, 1, -BlackHoleLocation.Z),\\n    \\t\\t\\tFPlane(0, 0, 0, 1)\\n    \\t\\t);\\n    \\t\\tswitch (OrbitDataArr[Index].RotationAngleArr.Num())\\n    \\t\\t{\\n    \\t\\tcase 1: {\\n    \\t\\t\\t/*\\n    \\t\\t\\tXAxisRotation = FMatrix(\\n    \\t\\t\\t\\tFPlane(1, 0, 0, 0),\\n    \\t\\t\\t\\tFPlane(0, FMath::Cos(OrbitDataArr[Index].RotationAngleArr[0]), -FMath::Sin(OrbitDataArr[Index].RotationAngleArr[0]), 0),\\n    \\t\\t\\t\\tFPlane(0, FMath::Sin(OrbitDataArr[Index].RotationAngleArr[0]), FMath::Cos(OrbitDataArr[Index].RotationAngleArr[0]), 0),\\n    \\t\\t\\t\\tFPlane(0, 0, 0, 1)\\n    \\t\\t\\t);\\n    \\t\\t\\t*/\\n    \\t\\t}\\n    \\t\\t\\t\\tbreak;\\n    \\t\\tcase 2: {\\n    \\t\\t\\t/*\\n    \\t\\t\\tXAxisRotation = FMatrix(\\n    \\t\\t\\t\\tFPlane(1, 0, 0, 0),\\n    \\t\\t\\t\\tFPlane(0, FMath::Cos(OrbitDataArr[Index].RotationAngleArr[0]), -FMath::Sin(OrbitDataArr[Index].RotationAngleArr[0]), 0),\\n    \\t\\t\\t\\tFPlane(0, FMath::Sin(OrbitDataArr[Index].RotationAngleArr[0]), FMath::Cos(OrbitDataArr[Index].RotationAngleArr[0]), 0),\\n    \\t\\t\\t\\tFPlane(0, 0, 0, 1)\\n    \\t\\t\\t);\\n    \\t\\t\\tYAxisRotation = FMatrix(\\n    \\t\\t\\t\\tFPlane(FMath::Cos(OrbitDataArr[Index].RotationAngleArr[1]), 0, FMath::Sin(OrbitDataArr[Index].RotationAngleArr[1]), 0),\\n    \\t\\t\\t\\tFPlane(0, 1, 0, 0),\\n    \\t\\t\\t\\tFPlane(-FMath::Sin(OrbitDataArr[Index].RotationAngleArr[1]), 0, FMath::Cos(OrbitDataArr[Index].RotationAngleArr[1]), 0),\\n    \\t\\t\\t\\tFPlane(0, 0, 0, 1)\\n    \\t\\t\\t);\\n    \\t\\t\\t*/\\n    \\t\\t}\\n    \\t\\t\\t\\tbreak;\\n    \\t\\tcase 3: {\\n    \\t\\t\\t/*\\n    \\t\\t\\tXAxisRotation = FMatrix(\\n    \\t\\t\\t\\tFPlane(1, 0, 0, 0),\\n    \\t\\t\\t\\tFPlane(0, FMath::Cos(OrbitDataArr[Index].RotationAngleArr[0]), -FMath::Sin(OrbitDataArr[Index].RotationAngleArr[0]), 0),\\n    \\t\\t\\t\\tFPlane(0, FMath::Sin(OrbitDataArr[Index].RotationAngleArr[0]), FMath::Cos(OrbitDataArr[Index].RotationAngleArr[0]), 0),\\n    \\t\\t\\t\\tFPlane(0, 0, 0, 1)\\n    \\t\\t\\t);\\n    \\t\\t\\tYAxisRotation = FMatrix(\\n    \\t\\t\\t\\tFPlane(FMath::Cos(OrbitDataArr[Index].RotationAngleArr[1]), 0, FMath::Sin(OrbitDataArr[Index].RotationAngleArr[1]), 0),\\n    \\t\\t\\t\\tFPlane(0, 1, 0, 0),\\n    \\t\\t\\t\\tFPlane(-FMath::Sin(OrbitDataArr[Index].RotationAngleArr[1]), 0, FMath::Cos(OrbitDataArr[Index].RotationAngleArr[1]), 0),\\n    \\t\\t\\t\\tFPlane(0, 0, 0, 1)\\n    \\t\\t\\t);\\n    \\t\\t\\tZAxisRotation = FMatrix(\\n    \\t\\t\\t\\tFPlane(FMath::Cos(OrbitDataArr[Index].RotationAngleArr[2]), -FMath::Sin(OrbitDataArr[Index].RotationAngleArr[2]), 0, 0),\\n    \\t\\t\\t\\tFPlane(FMath::Sin(OrbitDataArr[Index].RotationAngleArr[2]), FMath::Cos(OrbitDataArr[Index].RotationAngleArr[2]), 0, 0),\\n    \\t\\t\\t\\tFPlane(0, 0, 1, 0),\\n    \\t\\t\\t\\tFPlane(0, 0, 0, 1)\\n    \\t\\t\\t);\\n    \\t\\t\\t*/\\n    \\t\\t\\tZAxisRotation = FMatrix(\\n    \\t\\t\\t\\tFPlane(FMath::Cos(OrbitDataArr[Index].XYAngle), -FMath::Sin(OrbitDataArr[Index].XYAngle), 0, 0), // * [O.x]\\n    \\t\\t\\t\\tFPlane(FMath::Sin(OrbitDataArr[Index].XYAngle), FMath::Cos(OrbitDataArr[Index].XYAngle), 0, 0), // * [O.y]\\n    \\t\\t\\t\\tFPlane(0, 0, 1, 0),\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   // * [O.z]\\n    \\t\\t\\t\\tFPlane(0, 0, 0, 1)\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  // * [1]\\n    \\t\\t\\t); //( O.x * Cos() - O.y * Sin(), O.x * Sin() + O.y * Cos(), O.z, 1) ---> O = OrbitingActorLocation\\n    \\t\\t}\\n    \\t\\t\\t\\tbreak;\\n    \\t\\tdefault: break;\\n    \\t\\t}\\n    \\t\\tXYZToBlackHole = FMatrix(\\n    \\t\\t\\tFPlane(1, 0, 0, BlackHoleLocation.X),\\n    \\t\\t\\tFPlane(0, 1, 0, BlackHoleLocation.Y),\\n    \\t\\t\\tFPlane(0, 0, 1, BlackHoleLocation.Z),\\n    \\t\\t\\tFPlane(0, 0, 0, 1)\\n    \\t\\t);\\n    \\t\\tXYZVec = FVector4(\\n    \\t\\t\\tOrbitingActorLocation.X,\\n    \\t\\t\\tOrbitingActorLocation.Y,\\n    \\t\\t\\tOrbitingActorLocation.Z,\\n    \\t\\t\\t1\\n    \\t\\t);\\n    \\t\\t//XYZTransformation = XYZToBlackHole * \\n    \\t\\t//\\t\\t\\t\\t\\t\\tZAxisRotation * \\n    \\t\\t//\\t\\t\\t\\t\\t\\t\\tYAxisRotation * \\n    \\t\\t//\\t\\t\\t\\t\\t\\t\\t\\tXAxisRotation * \\n    \\t\\t//\\t\\t\\t\\t\\t\\t\\t\\t\\tXYZToWorldOrigin;\\n    \\t\\t//TransformedVec = XYZTransformation.TransformFVector4(XYZVec);\\n    \\t\\tTransformedVec = XYZToBlackHole.TransformFVector4(\\n    \\t\\t\\tZAxisRotation.TransformFVector4(\\n    \\t\\t\\t\\tYAxisRotation.TransformFVector4(\\n    \\t\\t\\t\\t\\tXAxisRotation.TransformFVector4(\\n    \\t\\t\\t\\t\\t\\tXYZToWorldOrigin.TransformFVector4(XYZVec)\\n    \\t\\t\\t\\t\\t)\\n    \\t\\t\\t\\t)\\n    \\t\\t\\t)\\n    \\t\\t);\\n    \\t\\tTempArr[Index]->GetOwner()->SetActorLocation(TransformedVec);\\n    \\t\\tif(!OrbitDataArr[Index].OrbitOrientation.IsIdentity())\\n    \\t\\t{\\n    \\t\\t\\t\\n    \\t\\t}\\n    \\t\\tDrawDebugSphere(\\n    \\t\\t\\tGetWorld(),\\n    \\t\\t\\tNextLocation,\\n    \\t\\t\\t5,\\n    \\t\\t\\t2,\\n    \\t\\t\\tFColor::White,\\n    \\t\\t\\tfalse,\\n    \\t\\t\\t3.f,\\n    \\t\\t\\t0,\\n    \\t\\t\\t2.f\\n    \\t\\t);\\n    \\t}\\n    \\tif(PreviouslyOverlapppedComponentArr.Num() > 0)\\n    \\t{\\n    \\t\\tfor(UPrimitiveComponent* PreviouslyOverlappedComponent : PreviouslyOverlapppedComponentArr)\\n    \\t\\t{\\n    \\t\\t\\tif(!OverlappedComponentArr.Contains(PreviouslyOverlappedComponent))\\n    \\t\\t\\t{\\n    \\t\\t\\t\\tPreviouslyOverlappedComponent->SetEnableGravity(true);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\tPreviouslyOverlapppedComponentArr = OverlappedComponentArr;\\n    \\t\\n    }\\n\\n&#x200B;\\n\\nAt the end of the video, you can see that the build just failed, ignore that, the FMatrix::TransformVector4() doesn\\'t work neither.\\n\\nAlso, in the GenerateOrbitData(), I\\'m using a quaternion to rotate the orbiting actor around its own center, ignore it for now.\\n\\nCan you guys tell me my mistakes? Also, to avoid a gimbal lock (because I\\'m using Euler angles), can you tell how to do what I\\'m trying to do, instead using rotation matrices?\\n\\nThanks! =)', 'comments': ['Your goal and exact problem are not clear to me. If you can add a voice-over to video, that might help to understand.']}]"
    },
    {
        "thought": "The search on Reddit did not yield any relevant results about the website \"uproperties.com\" or the company \"United Properties.\" The results are unrelated to the query and provide no information regarding the legitimacy of the website in question. Given the information from the website's content, WHOIS data, certificate information, and the lack of negative information from social media and community forums, there are no indications that \"uproperties.com\" is a scam website. The website seems to be a legitimate commercial real estate development and investment company. I now know the final answer. Based on the analysis, \"uproperties.com\" does not exhibit any characteristics of a scam website. It appears to be a legitimate business website.",
        "action": "FinalAnswer",
        "action_input": "N/A",
        "observation": {
            "result": "false",
            "scam_type": "null",
            "reason": "The website 'uproperties.com' has valid and recent SSL certificate information long-standing domain registration since 1996 professional content related to legitimate business activities and no indications of scam characteristics such as unusually low prices unrealistic money claims or psychological triggers. There is also no negative feedback or scam reports from social media or community forums."
        }
    }
]